# linux操作系统

平时看起来最简单的文件操作，通过阅读 Linux 代码，能学到从应用层、系统调用层、进程文件操作抽象层、虚拟文件系统层、具体文件系统层、缓存层、设备 I/O 层的完美分层机制，尤其是虚拟文件系统对于接入多种类型文件系统的抽象设计，在很多复杂的系统里面，这个思想都能用得上。

文件操作在各个层的数据结构的关联：

![image-20221013141213627](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20221013141213627.png)

# 要求：

1. 熟练使用 Linux 命令行
2. 通过系统调用或者 glibc，进行程序设计
3. 了解 Linux 内核机制，反复研习重点突破
4. 阅读 Linux 内核代码，聚焦核心逻辑和场景
5. 实验定制化 Linux 组件，可以自己实现一个设备驱动程序，实现一个自己的系统调用，或者实现一个自己的文件系统等等。
6. 面向真实场景的开发

![image-20220901161333368](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901161333368.png)

![image-20220901163635892](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901163635892.png)

![image-20220901163945421](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901163945421.png)

![image-20220901164935608](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901164935608.png)

##  创建进程 

创建进程的总结： 

1、Linux中父进程调用fork创建子进程。 

2、父进程调用fork时，子进程拷贝所有父进程的数据接口和代码过来。

 3、当前进程是子进程，fork返回0；当前进程是父进程，fork返回子进程进程号 

4、如果返回0，说明当前进程是子进程，子进程请求execve系统调用，执行另一个程序。

 5、如果返回子进程号，说明当前进程是父进程，按照原父进程原计划执行。

 6、父进程要对子进程负责，调用waitpid将子进程进程号作为参数，父进程就能知道子进程运行完了没有，成功与否。

 7、操作系统启动的时候先创建了一个所有用户进程的“祖宗进程”，课时1，第3题A选项：0号进程是所有用户态进程的祖先 

创建进程的系统调用：fork

执行另一个程序的系统调用：execve 

将子进程的进程号作为参数传给它，父进程就能知道子进程运行完了没有，成功与否：waitpid

##   内存管理

内存管理总结

 1、每个进程都有独立的进程内存空间，互相之间不干扰。（隔离性） 

2、进程内存空间，存放程序代码的部分，称为代码段（Code Segment）。

 3、存放进程运行中产生数据的部分，称为数据段（Data Segment）。

 4、进程写入数据的时候，现用现分物理内存给进程使用。 

5、分配内存数量比较小时，使用brk调用，会和原来的堆数据连在一起。

 6、需要分配的内存数据量比较大的时候，使用mmap，重新划分一块内存区域。 

分配较小内存数量，和原来堆内数据连在一起：brk 

  分配较大内存数量，重新划分一块内存区域：mmap

##   文件管理       

文件的操作六个最重要系统调用：

       打开文件：open 
    
      关闭文件：close 
    
      创建文件：creat 
    
      打开文件后跳到文件某个位置：lseek
    
       读文件：read
    
       写文件：write
    
       Linux一切皆文件
    
       一切皆文件的优势即使统一了操作的入口，提供了极大的便利。

##  信号处理（异常处理）

 进程执行过程中一旦有变动，就可以通过信号处理服务及时处理。

##   进程间通信 

有两种方式实现进程间通信 

消息队列方式 

      创建一个新的队列：msgget 
      发送消息到消息队列：msgsnd 
      取出队列中的消息：msgrcv

  共享内存方式

      创建共享内存块：shmget 
    
      将共享内存映射到自己的内存空间：shmat 
    
      利用信号量实现隔离性       
    
      占用信号量：sem_wait 
    
      释放信号量：sem_post 

##   网络通信 

  网络插口：socket 

  网络通信遵循TCP/IP网络协议栈

##  glibc 

      glibc是Linux下开源标准C库
    
       glibc把系统调用进一步封装
    
       sys_open对应glibc的open函数
    
       一个单独的glibcAPI可能调用多个系统调用 
    
      printf函数调用sys_open、sys_mmap、sys_write、sys_close等等系统调用
## 计算机的工作模式

![image-20220901170801478](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901170801478.png)

CPU包括三个部分，运算单元、数据单元和控制单元。

**运算单元**只管算，例如做加法、做位移等等。但是，它不知道应该算哪些数据，运算结果应该放在哪里。

运算单元计算的数据如果每次都要经过总线，到内存里面现拿，这样就太慢了，所以就有了**数据单元**。数据单元包括 CPU 内部的缓存和寄存器组，空间很小，但是速度飞快，可以暂时存放数据和运算结果。

有了放数据的地方，也有了算的地方，还需要有个指挥到底做什么运算的地方，这就是**控制单元**。控制单元是一个统一的指挥中心，它可以获得下一条指令，然后执行这条指令。这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。

![image-20220901171011038](linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220901171011038.png)

CPU 包括: 运算单元, 数据单元, 控制单元 

○运算单元 不知道算哪些数据, 结果放哪

○数据单元 包括 CPU 内部缓存和寄存器, 暂时存放数据和结果

○控制单元 获取下一条指令, 指导运算单元取数据, 计算, 存放结果

●进程包含代码段, 数据段等, 以下为 CPU 执行过程: 

○控制单元 通过指令指针寄存器(IP), 取下一条指令, 放入指令寄存器中 

■指令包括操作和目标数据

○数据单元 根据控制单元的指令, 从数据段读数据到数据寄存器中

○运算单元 开始计算, 结果暂时存放到数据寄存器

●两个寄存器, 存当前进程代码段和数据段起始地址, 在进程间切换

●总线包含两类数据: 地址总线和数据总线

●x86 开放, 统一, 兼容

●数据单元 包含 8个 16位通用寄存器, 可分为 2个 8位使用

●控制单元 包含 IP(指令指针寄存器) 以及 4个段寄存器 CS DS SS ES 

○IP 存放指令偏移量

○数据偏移量存放在通用寄存器中

○﻿﻿段地址<<4 + 偏移量﻿ 得到地址

●32 位处理器

●通用寄存器 从 8个 16位拓展为 8个 32位, 保留 16位和 8位使用方式

●IP 从 16位扩展为 32位, 保持兼容

●段寄存器仍为 16位, 由段描述符(表格, 缓存到 CPU 中)存储段的起始地址, 由段寄存器选择其中一项 

○保证段地址灵活性与兼容性

●16位为实模式, 32位为保护模式

●刚开机为实模式, 需要更多内存切换到保护模式