计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。

计算机的软件结构采用了”分层“的思想，层与层是独立的，然而层层之间是必须要通讯的，这里的通讯就是接口

![image-20221013134701651](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20221013134701651.png)

​                                    计算机软件体系结构

## 静态链接

编译和链接一起的过程统称“构建（Build）”

Build包括以下四个步骤：

1.预处理（Prepressing）

2.编译（Compilation）

3.汇编（Assembly）

4.链接（Linking）

**预处理（Prepressing）**

主要处理源码中“#”开始的预编译指令。

例如“#include”，“#define“等。

- 一般是先删除所有”#define“，为什么要删除呢？

- 然后处理条件预编译指令，如”#if“，#”elif“、”#else“等

- 接着处理”#include“或”#import“

- 接着删除注释“//”和“/* */”。

- 还有添加行号和文件名标识。调试用的行号信息以及编译失败的时候显示行号的。

- 最后是保留#Pragma编译指令。

**编译（Compilation）**

 就是把前一步处理完的文件进行一系列的词法分析、语法分析、语义分析和优化产生汇编代码文件。

![image-20221013134711279](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20221013134711279.png)

​                              编译过程

**汇编（Assembly）**

将上一步骤生成的汇编代码转变成机器可以执行的指令。这里主要讲的是汇编原理。

**链接（Linking）**

主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正常的衔接。

我们写的代码一般是按模块划分的，各个模块经过前面三步的操作，都是相互独立的，不能相关调用。例如一个main模块，写来一行fun1函数， 而fun1函数在模块A中，在main模块如何调用fun1呢？经过前面三步，生成了独立main模块和A模块。其中A模块的fun1地址只有A模块知道，main模块是不清楚的，所以main模块是无法调用fun1函数的。

那要怎么才能使main的fun1被调用起来呢？这里就要用到链接。

链接就是把独立编译的各个模块，按照需要将各个模块“组转”起来。其过程又包括：

1.地址和空间分配（Address and Storage Allocation）

2.符号决议（Symbol Resolution）

3.重定位（Relocation）

![image-20221010075603641](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20221010075603641.png)

​                                      链接过程

我们编写的代码会生成目标文件，然后经过链接步骤，最终生成可执行文件。

目标文件里面包含有ELF头文件区域、代码区域、数据区域等等

![image-20221010075803864](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20221010075803864.png)

​                                               ELF结构

各个区域以“段”（Segment）的形式分别存储。

**ELF头文件**

该部分存储了与目标平台相关的数据。

例如：ELF魔法数，字节长度，存储方式等数据。

![image-20221010075939479](%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.assets/image-20221010075939479.png)

**代码段（Code Section）**

存储：编译后的机器指令。一般称为”.code”或“.text”段.

**数据段（Data Section）**

存储：全局变量和静态变量数据。一般称“.data”段

**.bss 段**

为未初始化的全局变量和静态变量预留位置，不存储实际内容。这些变量的默认数据都是0。

**.rodata 段**

存放只读数据。在该区域内一个典型的例子就是printf()用到的字符串常量“%d\n”，这样保证了不可修改性。

这样设计至少有两个好处：

1.在语义上支持了C++读const关键字

2.设置只读，该段的任何修改都是非法的，保证了程序的安全性。

**自定义段：**

 一般情况下，上述的段区域为程序对应好了相关的存储位置。

但是有些情况下，自己写的变量或函数希望能够存放到自己所指定的段中去。这样就出现了“自定义段”。

一般通过“__attribute__((section(“name”)))”属性

就可以把变量或者函数存放到“name”作为段名的段中。

**“符号”（Symbol）段**

各个模块通过链接而拼装成一个可执行程序。所以拼装的规则是很重要的。

在链接过程中，目标文件的相互拼装，实际上是地址的相互引用。即对函数和变量地址的引用。例如main模块调用了fun1函数，而fun1函数在另外一个A模块中。要想main模块准确地调用了A模块的fun1函数，必须正确的引用到A模块fun1函数的地址。那如何来保证正确呢？同样的B模块也有一个fun1函数。

那又怎么解决函数重名的问题呢？这个就需要对函数按模块按函数名称进行唯一标识。当然这个方式也适用于变量。

总结这段意思：就是将函数和变量进行符号化，并且保证符号在全局范围内是唯一的。

保证符号唯一性一般有下面2个方法：

1.所有的符号名（函数或变量）前面加上“_”. 最典型的例子就是 C语言的 “_foo”。当然有些语言是前后都加“_”.例如“_foo_”.

2.对于大型项目来说，方式1不能满足需要，于是就出现了名称空间（Namespace）的方法解决多模块的符号冲突问题。还记得C++语言中的Namaspace宏吗？

extern “C”

这个做C语言很熟悉的关键字。这个关键字是说明大括号内部的代码要当作C语言来处理。不能按C++的名称修饰机制来处理。

“__cplusplus”

这个宏是来判断编译单元是不是C++代码。因为我们经常C语言和C++混写。

一个典型的例子就是memset函数，在C语言环境使用memset，编译器一般会正确地引用这个函数。但是在C++环境中，就会将memset函数按C++的修饰机制进行修饰，最终可能是_Z6memsetPvii的格式。这样就无法与C语言的memset进行链接了。对于C++来说，必须使用exter “C”来声明。所以为了兼容C语言和C++。最终变成了

```
#ifdef __cplusplus
extern “C” {
#endif
void *memset(void*, int, size_t);
#ifdef __cplusplus
}
#endif
```

ELF结构是编译过程中目标文件的主要内容。它里面有.text、.data、.bss、.rodata等段区域，这些段分别存储代码指令，全局变量和静态变量数据，未初始化的变量预留位置和只读数据。除此之外还有很多其他重要的段区域：

**.rel段**

重定位表（Relocation Table），里面保存了重定位相关的信息。这里的主要信息部分是重定位函数。通过这张表，我们就可以知道.o文件（目标文件）有多少需要重定位的函数。在后面的重定位流程中，就只需要对该表的函数进行重定位即可。

对重定位表再细说下，重定位表又可以分代码段和数据段的重定位，即.rel.text和.rel.data。这样就可以在重定位流程中对代码段的指令和数据段的数据，要重定位的部分进行重定位。

还有动态链接中的.rel.dyn 和.rel.plt 。他们分别对应静态链接中.rel.text和.rel.data(指令和数据)。前者是对”.got”段以及数据段的段修正。后者是对函数引用的修正，具体重定位的位置在“.got.plt”部分.

**.interp段**

该段内容是指定动态链接器的名称.在动态链接的章节部分，动态对象的调用是需要动态链接器的。interp段就像一个配置文件，该配置文件配置了动态链接器的名称和调用路径。

**.dynamic段**

指定了动态链接器所需要的基本信息，具体如依赖哪些共享对象，符号表、重定位表的位置和共享对象初始化代码地址等信息。

.interp是概要，.dynamic是具体详细的信息

**.dynsym 段（Dynaimc Symbo Table）**

动态符号表。保存了动态链接中各个模块的符号导入导出关系。这样就知道动态对象（动态库）的导入导出函数了。

**.symtab(Symbol Table)**

静态符号表。保存所有该目标文件的符号的定义和引用。

有了静态符号表就知道该目标文件的所有函数了。同时可以遍历所有目标文件，这样就知道了执行文件的函数情况了。

静态链接，用一句话概括就是把所有的目标文件链接起来，生成一个可执行文件。这里与动态链接的区别就是动态链接是在装载的时候进行链接。

再具体说就是，静态链接是在编译时期，对目标文件进行空间和地址分配、符号解析、重定位等操作之后生成可执行文件。而动态链接是在装载时期（模块调用时候），对模块进行空间和地址分配、符号解析、重定位等操作之后被调用起来。

在说静态链接步骤之前，让我们先回想一个问题，两个源代码文件（a.c和b.c），经过编译过程，生成了a.o和b.o两个目标文件，再链接成一个可执行文件。这个过程具体是怎么链接成可执行文件呢？这就是下文链接过程中的牵涉到具体步骤了。

静态链接的步骤：

**1.空间和地址的分配**

扫描所有的目标文件，获取各个段的长度和位置并把各个段合并在一起，同时还获取符号表中所有的函数定义和引用，并把他们合并到一个全局符号表中。然后针对合并之后的总段进行各个段的虚拟地址映射。从而实现段段空间和地址的分配。

具体来说，a.o和b.o两个文件。扫描他们的.text，.data,.bss等等所有的段长度和位置，并合并成一个临时的c.o文件。这样所有的目标文件的段信息就合并到一个文件了。同时函数名（符号）的定义和引用也统一到一个全局符号表中。然后对c.o文件中的段进行虚拟地址的映射。

这里在插播下空间地址的分配方案，一般有两种方案：

1.按序叠加，

2.相似段合并。

按序叠加一般是按一定的次序排列起来。例如前面说的a.o和b.o文件的段排序，就是按如下的部分排列的：

(a部分).text1,.data1,.bss1（b部分）.text2,.data2,.bss2(c部分)。而相似段合并，就是把各个目标文件各个段按相似的部分进行合并。具体就是 .text1,.text2,.data1,.data2,.bss1,.bss2.

明显地方案2要好一些，业界也是采用方案2的。

**2.符号（函数）解析和重定位**

根据上一步骤的信息，再对各个段进行符号解析和重定位，这里也包括数据的重定位。

首先是符号地址的确定和解析。对于符号来说，它有一个基地址和偏移量，然后根据这两个数值可以确定符号的地址了。具体的基地址和偏移量的计算还是很复杂的。

重定位，简单来说是对符号的地址重新修正，使之指向真正的符号地址（从而能正常调用起来）。

举个简单例子说明下，在main模块中的main函数中调用A模块的foo()，在编译时期，一般给main中的foo()指定的地址为0xcbcb010101，而实际上A模块的foo()地址是0xcbcb0x3x8. 那么就需要把main中的foo()地址由0xcbcb010101 修正为0xcbcb0x3x8，才能正常调用foo()。这就是大致的重定位思想。真正的重定位是很复杂的，有一整套策略（包括不限于模块内怎么修正，模块外怎么修正），这还牵涉到重定位表。

通过上面两个步骤，就完成了整个链接过程。再简单概述下：链接过程就是把所有目标文件打包成一个可执行文件的过程。这其中主要的步骤是空间地址的分配、符号解析和重定位。

最后再补充一点知识:VMA（Virtual Memory Address）虚拟地址；LMA（Load Memory Address） 加载地址。在程序调用中一般是使用虚拟地址。即为虚拟内存中的虚拟地址。

还有一个ABI&API的知识。API（Application Programming Interface）一般指代码的接口，例如mac 所提供的开发人员的API接口。ABI（Application Binary Interface）是二进制层面的接口。例如可以说Object-C 中对象的内存分布是ABI。但是OC的内存管理机制就不算ABI。

## 动态链接

静态链接已经能够满足我们完成编译过程全部需求了，但是它也有两个致命的问题：空间浪费和更新困难。

所谓的空间浪费。即在程序启动的时候，就要把所有模块都加载起来。例如我们有登录、注册、首页、设置四个模块。在我们正常登录流程中，只用到了登录和首页两个模块，只有新用户才会用到注册模块；用户只有到了设置界面才用到设置模块。而对于一个登录用户来说，注册和设置模块一般很少用到。然而使用静态链接方式加载程序的话，在app启动就会把这四个模块都加载起来，这样算起来，空间就很浪费了。

对于更新困难也是一样，静态链接把所有目标文件打包在一起，形成一个整体。若想单独更新某个模块，是必须对整个app进行更新，而更新整个App又是要全部编译，很是麻烦。

为了解决这两个问题，动态链接就运用而生。动态链接的基本思想就是把链接的过程推迟到运行时再进行。具体实现就是把程序按模块拆分成相对独立模块，在运行的时候先链接调用的模块，然后再调用起来。实现按需链接、按需调用。

动态链接的步骤和静态链接一样，也是先空间地址的分配，然后是符号解析和重定位。他们的不同之处是调用的时机和调用对象不同。静态链接是在编译时期，而动态链接是在程序运行期间；静态链接是有个叫“ld”名称的静态链接器来完成， 而动态链接是由动态链接器完成的。动态链接器的名称是不同的。例如书中介绍的是ld-2.6.so 这样的动态链接器名。

对于动态链接器的流程一般是如下：首先动态链接器和普通的对象一样被加载并调用起来，只不过它比一般的动态对象（动态库）要早一些被调起来。在动态链接器被执行起来后，操作系统会把控制权交给动态链接器，然后由它来完成所有动态链接工作，在完成链接工作之后，再把控制权交还给系统，让系统继续执行其他操作。

注意事项：

1.在动态库装载过程中，还有一个比较重要的问题要考虑。即动态库能在任意地址装载。对此，一般的做法是：在装载时，优先确定模块的装载地址，即目标地址，然后目标地址结合绝对地址引用进行全部模块的重定位，这个说法也就是所谓的装载时重定位。

2.对于装载时重定位的方案，也有一个缺陷：装载的代码指令无法在多个进程共享，这样就失去了节省内存的优势。例如装载了一个printf（）的指令，我们希望这块指令能在所有模块使用。而装载时重定位就不能解决这个问题。然后提出一个地址无关代码（PIC Position-independent Code）的技术，它具体来说：把指令中哪些哪些需要被修正的部分剥离出来，放在.data区域。.text区域不变，而.data部分是根据不同进程会生成不同的数据副本。这样公共的代码指令可以共享给各个进程了。

这里引申一个知识点：对于共享对象的数据段（.data）来说，每个进程都有一份数据段（.data）的副本。这就解释了同一个sum（int a,int b）函数，在不同的进程中调用，是不会相互影响的。

3.动态链接也不是十分完美的，它有个比较大的问题就是性能问题。因为在运行期间，对模块进行空间地址分配，符号解析和重定位，这些操作都要耗时一些。通过计算，动态链接比静态链接要多消耗1%—5%的性能。当然减少性能的耗损也有一些方法，例如延迟绑定（Lazy Binding）。

最后在讲一下装载的概念。其实《程序员的自我修养》主要讲三大问题：链接，装载和库。

链接一般讲静态链接和动态链接以及之前的预处理、编译步骤；

装载就是让可执行文件在虚拟空间中建立映射关系并开始执行。具体来说有三个步骤：

1.为进程创建独立的虚拟地址空间。

2.获取文件头信息， 建立虚拟空间与可执行文件的映射关系。

3.将CPU的指令寄存器设置到可执行文件的入口地址并启动运行。

库，就是公共库，动态库之类调用关系。